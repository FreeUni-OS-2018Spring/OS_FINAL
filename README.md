# OS_FINAL: Network Filesystem

Mikheil Zhghenti   mzhgh14@freeuni.edu.ge


პროექტი კომპილირდება *make*-ს საშუალებით. </br>
ქსელურ ფაილურ სისტემას აქვს ორი ძირითადი კომპონენტი, ესენია: კლიენტი და სერვერი. 

თითოეული მათგანის გაშვების სინოფსისის მაგალითები: </br>
**კლიენტი** *./net_raid_client client_config.txt* და </br>
**სერვერი** *./net_raid_server 127.0.0.1 10001 /home/misho/Desktop/storage1*

*სერვერის მიმოხილვა* </br>
სერვერი argv-დან შესაბამის პარამეტრებს იღებს და bind/listen-ით სტარტავს კონკრეტულ გადმოცემულ პორტზე "მომსახურებას". სერვერის ეფექტურ და უსაფრთხო ფუნქციონირებას(იმ გაგებით, რომ თუ კონკრეტულ request-ზე დაიქრაშა ჩვენი პროგრამა, სერვერი არ წყვეტს მუშაობას და აქტიური ახალი რექვესტის მისაღებად. ეს იმით, რომ თითოეულ მოთხოვნას ცალკე პროცესში ემსახურება.) სერვერის მხარეს შედარებით ნაკლები "საქმეა"(ლოგიკა მის მხარეს არაა დიდი რაოდენობით გატანილი), მას უფრო "კონკრეტული დავალებების" დამუშავება უწევს. მივმართავთ სერვერს, რომ შეასრულოს A სამუშაო: მიიღებს სერვერი A სამუშაობს, ასრულებს და შედეგს უკან გვიბრუნებს.

*კლიენტის მიმოხილვა*</br>
კლიენტის მთავარი მიზანი, არის მოცემული *task*-ის მართვა, მენეჯმენტი. უდიდესი ლოგიკაა სწორედ მის მხარესაა გატანილი. იგი იღებს გადაწყვეტილებას, თუ როგორ მოექცეს data-ს, როგორ შეინახოს და მაავე დროს performance-ზე ფიქრიც უწევს.

*პროექტის არქიტექტურა* </br>


**უტილ კლასები**</br>
**ლოგირება / კლასების დეკომპოზიცაა**</br>
**გამოყენებული კლასები და მეთოდები** </br>

**დეტალურად კლიენტი**</br>
კლიენტის გამოძახებისას, მას პარამეტრად გადმოეცემა configuration-ის მისამართი, სადაც ჩამოწერილია ყელა სერვერის მისამართი, სტორიჯების სახელები, ლოგირების ფაილის სახელი, ქეშის ზომა, თაიმაუთი, დასამაუნთებელი დირექტორიები და სხვა. </br>

პროექტის სტრუქტურის მოწყობა ისე გადავწყვიტე, რომ თითოეულ Storage-ზე კონკრეტული 1 პროცესი მუშაობდეს. ეს უზრუნველყოფს იმას, რომ (ზემოთ უკვე ავღნიშნეთ), დამოუკიდებელი პროცესები საერთოდ "პრობლემას" უფრო ნაკლებად წარმოქმნიან. და თითოეული პროცესის მუშაობა საერთო ჯამში უფრო ეფექტური გამოვა. </br>

